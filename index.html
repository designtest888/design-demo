<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>3D Schrankansicht</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <style>
        html, body {
            margin: 0; padding: 0; overflow: hidden; height: 100%;
            font-family: system-ui, sans-serif; background: #f0f0f0;
        }
        #ui {
            position: absolute; z-index: 10; top: 10px; left: 10px;
            padding: 8px 12px; background: rgba(255,255,255,0.9);
            border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            font-size: 13px;
        }
        .hint { font-size: 11px; color: #555; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; display: block; }
        .btn {
            margin-top:6px; margin-right:4px; padding:4px 8px; border-radius:4px;
            border:1px solid #ccc; background:#f7f7f7; cursor:pointer; font-size:11px;
        }
        .btn:hover { background:#eaeaea; }
    </style>
</head>
<body>

<div id="ui">
    <strong>3D Schrankansicht</strong><br>
    <span class="hint">Maus: Drehen = Linksklick â€¢ Zoomen = Mausrad â€¢ Verschieben = Rechtsklick</span>
    <div style="margin-top:6px;">
        <button class="btn" id="btnStyleNeutral">Neutral</button>
        <button class="btn" id="btnStyleBright">Hell</button>
        <button class="btn" id="btnStyleWarm">Warm</button>
    </div>
</div>

<canvas id="renderCanvas"></canvas>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

async function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.97, 0.97, 0.97, 1);

    // ðŸŽ¥ Kamera-Grundsetup (Details erst nach dem Modell-Laden)
    const camera = new BABYLON.ArcRotateCamera("camera",
        -Math.PI * 0.75,      // vor dem Schrank, schrÃ¤g links
        Math.PI * 0.22,       // AugenhÃ¶he ca. 120-140 cm
        10,
        BABYLON.Vector3.Zero(),
        scene
    );
    camera.attachControl(canvas, true);
    camera.lowerRadiusLimit = 1.5;
    camera.upperRadiusLimit = 50;
    camera.wheelPrecision = 120;
    camera.pinchDeltaPercentage = 0.002;

    // ðŸ’¡ Studio-Licht
    const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
    hemi.intensity = 0.6;

    const dir = new BABYLON.DirectionalLight("dir",
        new BABYLON.Vector3(-1, -2, -1), scene
    );
    dir.position = new BABYLON.Vector3(5, 8, 5);
    dir.intensity = 0.9;

    const env = scene.createDefaultEnvironment({
        createGround: true, groundSize: 20, enableGroundShadow: true, groundShadowLevel: 0.65
    });

    // ðŸ“¦ Modell laden
    try {
        const loaded = await BABYLON.SceneLoader.ImportMeshAsync("", "model/", "schrank.glb", scene);
        const root = loaded.meshes[0];

        // âž• Modell in die Mitte setzen
        root.position = BABYLON.Vector3.Zero();

        // ðŸŽ¯ Kamera exakt auf Modell ausrichten (AugenhÃ¶he)
        root.computeWorldMatrix(true);
        const box = root.getBoundingInfo().boundingBox;
        const center = box.centerWorld;

        // HÃ¶he auf 1.25 m (AugenhÃ¶he)
        center.y = 1.25;
        camera.setTarget(center);

        // Abstand proportional zur GrÃ¶ÃŸe
        const size = box.maximumWorld.subtract(box.minimumWorld);
        const maxSize = Math.max(size.x, size.y, size.z);
        camera.radius = maxSize * 2.2;

        // Verhindern unter den Boden zu drehen
        camera.lowerBetaLimit = 0.05;
        camera.upperBetaLimit = Math.PI / 2.2;

        // ðŸŒ— Materialien von hinten beleuchten (Fehler aus SketchUp)
        scene.materials.forEach(mat => {
            if (mat.backFaceCulling !== undefined) mat.backFaceCulling = false;
            if (mat.twoSidedLighting !== undefined) mat.twoSidedLighting = true;
        });

        // ðŸŒ‘ Schatten
        const sg = new BABYLON.ShadowGenerator(1024, dir);
        sg.useBlurExponentialShadowMap = true;
        sg.blurKernel = 16;
        loaded.meshes.forEach(m => { if (m !== env.ground) sg.addShadowCaster(m); });

        // ðŸŽ¨ Buttons aktivieren
        setupMaterialStyles(scene);

    } catch (e) {
        console.error(e);
        alert("3D-Modell konnte nicht geladen werden.");
    }

    return scene;
}

// ðŸŽ¨ Material-Stile
function setupMaterialStyles(scene) {
    const n = document.getElementById("btnStyleNeutral");
    const b = document.getElementById("btnStyleBright");
    const w = document.getElementById("btnStyleWarm");

    scene.materials.forEach(mat => {
        if (!mat._backup && mat.albedoColor) {
            mat._backup = mat.albedoColor.clone();
        }
    });

    function apply(type) {
        scene.materials.forEach(mat => {
            if (!mat.albedoColor) return;
            const c = mat._backup;

            if (type === "neutral") mat.albedoColor = c.clone();
            if (type === "bright")  mat.albedoColor = c.scale(1.15);
            if (type === "warm")    mat.albedoColor = new BABYLON.Color3(c.r*1.05+0.03, c.g*1.02+0.01, c.b*0.97-0.02);
        });
    }

    n.onclick = () => apply("neutral");
    b.onclick = () => apply("bright");
    w.onclick = () => apply("warm");
}

createScene().then(scene => engine.runRenderLoop(() => scene.render()));
window.addEventListener("resize", () => engine.resize());
</script>

</body>
</html>
